<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[线性表]]></title>
      <url>%2F2017%2F05%2F03%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;using namespace std;#define LIST_INIT_SIZE 100 // 线性储存空间的初始分配量#define LISTINCREMENT 10 //线性储存空间的分配鞥量（当线性表的空间不够用时，进行增加的单位）typedef int ElemType; // 数据元素的类型，//定义线性表元素typedef struct &#123; ElemType *elem; // 储存空间的基地址 int length; //当前线性表的长度 int liestsize; //当前分配的储存容量&#125;SqlList;//定义线性表的操作// createint initList(SqlList &amp;L) &#123; L.elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType));// 开辟一个储存空间，把这个储存空间的基地址赋值给elem if (!L.elem) &#123; return -1;// 分配失败 &#125; L.length = 0;//当前长度 L.liestsize = LIST_INIT_SIZE;//当前分配量 return 0;&#125;//插入元素int listInsert(SqlList &amp;L, int i, ElemType e) &#123; //判断插入位置是否合法 if (i&lt;1 || i&gt;L.length) return -1; //判断内存是否够用 if (L.length &gt;= L.liestsize) &#123; ElemType *newBase = (ElemType *)realloc(L.elem, (L.liestsize + LISTINCREMENT)*sizeof(ElemType));//增加内存 if (!newBase) return -1;//储存空间分配失败 L.elem = newBase;//新基址，疑问：需要指明吗？ L.liestsize += LISTINCREMENT; &#125; ElemType *q, *p;// q = &amp;(L.elem[i - 1]);//取出要插入位置的地址，下标是0开始 for (p = &amp;(L.elem[L.length - 1]); p &gt;= q; --p) &#123; *(p + 1) = *p; &#125; *q = e; ++L.length; return 0;&#125;//删除元素int listDelete(SqlList &amp;L, int i, ElemType &amp;e) &#123; //判断删除位置是否合法 if (i&lt;1 || i&gt;L.length) return -1; //删除操作 ElemType *q, *p; p = &amp;(L.elem[i - 1]); e = *p; q = &amp;(L.elem[L.length - 1]); for (++p; p &lt; q; ++p) &#123; *(p - 1) = *p; &#125; --L.length; return 0;&#125;// 查找元素（按值查找）int LocateElem(SqlList L, ElemType x) &#123; int pos = -1;//用来记录查找到的位置 for (int i = 0; i &lt; L.length; i++) &#123; if (L.elem[i] == x) pos = i; &#125; return pos;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习第一章]]></title>
      <url>%2F2017%2F05%2F01%2Fpython-study-first-day%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# coding=utf-8import refrom urllib import urlopenfrom urllib2 import HTTPErrorfrom bs4 import BeautifulSoup# 周密的异常处理让代码复用# 获取网页titledef getTitle(url): try: # 检查URL是否正常工作 html = urlopen(url) except HTTPError as e: return None try: # 检查便签是否存在 bsObj = BeautifulSoup(html.read(), "html.parser") # 可有单个参数：content， 解析方式， 向网页提交内容：data title = bsObj.body.head # 了解HTML的标签格式 except AttributeError as e: return None return title# 训练使用 bs4 findAll 和 find# 通过属性查找标签# findAll()的参数设置# 当网站管理员对网页内容稍加更改，代码是否会失效# 把请求头设置成移动设备在线# 寻找隐藏在JavaScript里面的信息# findAll(tag, attributes, recursive, text, limit, keywords)# recursive 是 bool 值， 若为 true 则可以查找子标签的子标签， 否则只能查到一级标签， 默认true# text 是用内容去匹配 而不是标签属性# limit 范围限制参数 网页中前x项# keyword 选择具有指定属性的标签# find(tag, attributes, recursive, text, keywords)def useFind(url): try: html = urlopen(url) except HTTPError as e: return None try: bsObj = BeautifulSoup(html.read(), "html.parser") nameList = bsObj.findAll("span", &#123;"class": &#123;"green", "red"&#125;&#125;) # bsObj.findAll(text = "jerry") # 查找包含Jerry内容的标签数目 可利用len()获得 # bsObj.findAll(id= "text") 等同于bsObj.findAll("",&#123;"id": "text"&#125;) 由于class是Python保留字，可能会出错 # print bsObj.findAll(&#123;"h1", "h2", "h3", "h4", "h5", "h6"&#125;) # span标签， 以及span标签对应的属性, 还有属性值。属性:属性值 通过字典实现 except AttributeError as e: return None for name in nameList: print name.get_text() # get_text()去掉所有标签# 标签在文档中的位置来查找标签 导航树# 不是bs4函数总是处理当前标签的后代标签，子只有一个，后代有多个# bsObj.div.findAll("img") 会找出文档中第一个div标签，然后获得这个div后代里所有的行标签列表def findChild(url): try: html = urlopen(url) except HTTPError as e: return None try: bsObj = BeautifulSoup(html, "html.parser") print(bsObj.find("img",&#123;"src":"../img/gifts/img1.jpg"&#125;).parent.previous_sibling.get_text()) except AttributeError as e: return None for child in bsObj.find("table",&#123;"id": "giftList"&#125;).children: # 如果把.children 换成 .descendants 会产生所有后代 # 换成.tr.next_sibings（兄弟标签: 只会返回后面的兄弟标签, 所以选择标签行然后调用next_siblings）与previous_siblings相反 处理表格数据更简单 # 只使用标签容易丢失细节不稳定 ，尽量利用标签属性 # print child pass# 正则表达式 regular expression: regex 经典应用识别邮箱地址# 词组正则字符串# aa*至少出现一次1~n个a# (cc)*出现0~2n次cc# (d | )出现跟着空格的d或者只有空格# 邮箱格式： [A-Za-z0-9\._+]+@[A-Za-z]+\.(com|org|edu|net)# bs4 与 正则表达式 配合使用# find("img")明显不行 会有隐藏的图片def findImg(url): try: html = urlopen(url) except AttributeError as e: return None try: bsObj = BeautifulSoup(html) images = bsObj.findAll("image",&#123;"src":re.compile("\.\.\/img\/gifts/img.*\.jpg")&#125;) for image in images: print (image["src"])# 打印出图片的相对路径 except HTTPError as e: return None# myTag.attrs 返回标签的全部属性，Python字典对象# 获取图片资源位置 ： myImgTag.attrs["src"]# Lambda函数可作为findAll()的参数，# 要求是标签作为参数，返回结果是bool类型# 获得有两个属性的标签 ： soup.findAll(lambda: tag: len(tag.attrs)==2)# content = getTitle("http://www.jb51.net/article/65303.htm")# content = useFind("http://www.pythonscraping.com/pages/warandpeace.html")content = findChild("http://www.pythonscraping.com/pages/page3.html")if content is None: print "title not found"else: print content]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[deep learning]]></title>
      <url>%2F2017%2F04%2F24%2Fdeep-learning%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[python学习]]></title>
      <url>%2F2017%2F04%2F23%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399#-*-coding= utf-8-*-import math# python 学习# 任何语言都要翻译成机器语言最后运行，这就是编译器的作用， 语言越高级越抽象# 很多游戏后台均是用python开发# Python诞生于1989年# C贴近硬件，python有基础代码库# 首选网络应用，网站，后台# 脚本，把其他语言开发的程序再包装，方便使用# 解释型语言，运行速度很慢，一行一行翻译成机器码，C语言是运行前直接编译成机器码# 代码不能加密，c是编译型语言可以直接发布.exe机器码文件，# 跨平台，安装解释器# Python解释器也是开源，官方是Cpython用c语言开发# 如果要与java与.NET平台交互，可以使用Jython或者IronPython，不过更好是用网络调用来交互# 可以一边编辑器编辑代码，一边开一个交互式窗口，把部分代码粘贴到命令窗口中print 'The quick brown fox', ' jumps over','the lazy dog'# 逗号或变成空格输出# Python提供用户输入的函数, 参数是提醒用户输入的字符串# name = raw_input('please enter your name:')# print 'hello', name# 任何一套编程语言都有自己的一套语法，而且不能有歧义# 缩进的语句视为代码块，一般四个空格# 数据类型# 0x表示16进制# 整数永远是精确的，浮点数会有误差# 转义字符\，当要转义时# 或者用r""表示#用'''''',他自动识别换行符print '''line1line2line3'''# 布尔值和布尔代数的表示完全一致，也有or,and, not运算# None表示空值# 无需申明变量类型，不同变量类型亦可互相赋值# 称为动态语言# Python也需要理解指针的概念a= 'ABC'b=aa='XYZ'print b# 大写表示常量PI = 3.1415926# 字符编码# 8位表示一个字节，最早的编码表是ASCII编码# 现在是Unicode 2个字节表示一个符号# Unicode的储存就比ASCII大，当文本全是英文用Unicode就不划算# 本着节约的精神，utf-8出现了：有着霍夫曼树的味道# 常用的用一个字节表示，不常用的用多个字节# ASCII可以看成是utf-8的以部分，所以解决了兼容的问题# 计算机内存中统一使用Unicode，在转移时换成utf-8# 服务器会自动把Unicode换成utf-8传给浏览器print ord('A')print chr(40)# 若用中文则用r'...'print u'中'#print u'ABC'.encoding('utf-8')# unicode 转换成utf-8# len()返回字符串长度#print 'abc'.decoding('utf-8') # utf-8转化成Unicodeprint u'中文测试正常'# notepad++必须选择utf-8without bom编码#输出格式化字符串，与c语言类似c = 'world'print 'hello, %s'%ca='Michael'b=100000print 'Hi, %s, you have $%d.'%(a,b)# 格式化整数和浮点数，还可以指定是否补0和整数与小数的位数print '%2d-%02d'%(3,1), '%.2f'%3.1415926# 当不知如何选择时，%s永远起作用# 使用列表和元组classmates = ['Michael','Bob','Tracy']#从0开始类似数组,最后一个len(classmates)-1classmates.append('Adam')classmates.insert(1,'Jack')classmates.pop()classmates.pop(2)# 与数组不同的是，元素可以是多种数据类型，也可以是listL=['Apple',123,True]classmates=('Machael','Bob','Tracy')# 注意()既可以表示元组，也可以表示数学公式的小括号t=(1,)# 才是元组# 当元组的元素有list的时候，list那一部分是可变的，不变是指tuple的指向不变# 判断语句不可以少了冒号age =20if age&gt;=6: print 'teenanger'elif age&gt;18: print "adult"else: print 'kid'#循环：for...in 循环for x in range(5): print x# 2,while语句#raw_input()的返回值是字符串# birth =int(raw_input('birth：'))# dic存在的意义：# list越长耗时越长，# dic无论多大速度都不会改变，搜索方式与查字典类似# key-value 模式# 'Thomas' in d 判断value是不是在dic里面# 返回None的时候输出不会显示# dic 内部存放位置和key放入顺序没有关系# 与list相比:# dic 查找和插入的速度极快，不会随着key的增加而增加# 需要占用大量的内存，内存浪费多#list相反，插入和查找会随着元素的增加而增加#占用空间小，浪费的内存很少# 通过key来计算value的位置算法为hash算法(Hash)# set 也是一组key的集合，但是不储存values=set([1,1,2,2,3,3])print s# add(key) 可以重复添加# 空函数def nop(): passdef my_abs(x):# 检查参数是否合格 if not isinstance(x,(int,float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x# 返回多个值def move(x,y,step,angle=0): nx=x+step*math.cos(angle) ny=y-step*math.sin(angle) return nx, ny# 其实返回的是一个值，一个元组tuple，# 定义函数时，需要确定函数名和参数个数，还可以做类型检查# 函数的参数#可使用默认参数，可变参数，关键字参数def power(x,n=2): s=1 while n&gt;0: n=n-1 s=s*x return s#把变化小的参数设置成默认参数，放在后面def add_end(L=[]): L.append('END') return L# 第二次调用的时候，结果不对，L=['END','END'], L 会记录改变# 换成def add_end2(L=None): if L is None: L=[] L.append('END') return L # 默认参数必须指向不变对象# 可变参数：def calc(numbers): sum =0 for n in numbers: sum = sum+n*n return sum# 调用的时候需要先组装出一个list或者tuplecalc([1,2,3])calc((1,2,3))# 利用可变参数def calc2(*numbers): sum = 0 for n in numbers: sum = sum+n*n return sumcalc2(1,2,3)calc2(1,2,3,4)#python 允许你在list或者tuple前面加一个*号，把list或tuple元素变成可变参数传进去nums = [1,2,3]calc2(*nums)# 关键字参数# 可变参数允许你传入0或者任意个参数，这些可变参数在函数调用时自动组装成一个tuple，# 关键字参数允许你传入0个或者任意个含参数名的参数，这些关键字参数在函数内部自动组装成一个dicdef person(name,age,**kw): print 'name:',name,'age:',age,'other:',kwperson('Bob',35,city ='Beijing')# 先组装出一个dic，然后再传入kw=&#123;'city':'Beijing','job':'Engineer'&#125;person('Jack', 24,city=kw['city'],job=kw['job'])#或者简化person('Jack',24,**kw)# 参数组合：可以用必选参数，默认参数，可变参数，关键字参数，且顺序不能改变def fun(a,b,c=0,*args,**kw): print 'a=',a,'b=',b,'c=',c,'args=',args,'kw',kw# python 参数形态太灵活了# *args **kw 是python的写作习惯# 递归函数：函数内部调用自身def fact(n): if(n==1): return 1 return n*fact(n-1)# 计算机中函数调用是通过stack实现的：故递归调用的次数过多，会导致栈溢出# 尽量使用循环# 尾递归优化# 高级特性# 切片: 取list或tuple的部分元素 ：SliceL = ['Michael','Sarah','Tracy','Bob','Jack']print L[0:3]# 从索引0开始，直到索引3为止，但不包括索引3，取索引是0,1,2的元素，print L[-2:]print L[:2:2]#每两个取一个#字符串也可以切片操作print 'ABCDEFG'[:3]# slice 可以去掉很多不必要的循环# 迭代# 利用for循环遍历list或tuple# 默认情况下，dic迭代的是key，如果要迭代value可以用d = &#123;'a':1,'b':2,'c':3&#125;for key in d: print keyfor value in d.itervalues(): print value#同时迭代key和valuesfor k,v in d.iteritems() pass# 判断是否是可迭代对象from collections import Iterableisinstance('abc',Iterable)#对list实现类似java那样的下标循环for i,value in enumerate(['A','B','C']): pass# 列表生成式: 创建lista=range(1,11)# 利用循环：L=[]for x in range(1,11): L.append(x*x)# 一行语句搞定b=[x*x for x in range(1,11)]# 加上if判读c=[x*x for x in range(1,11) if x%2 == 0]# 双重循环d =[ m+n for m in 'ABC' for n in 'XYZ']# 列出当前目录下所有文件和目录名import os[d for d in os.listdir('.')]# 把一个list变成小写,增加判断s是不是stringL = ['Hello','World',18,'Apple',None][s.lower() for s in L if isinstance(s,str)]# 生成器：一边循环一边计算, 把[]换成()g = (x*x for x in range(10))print g.next()for s in g: print sdef fib(max): n,a,b = 0,0,1 while n&lt;max: yield b #print b a,b=b,a+b n=n+1# 函数式编程：一种抽象程度很高的编程范式,纯粹的函数式编程编写的函数没有变量# 特点：允许把函数本身作为参数传入另一个函数，还允许返回一个参数# 高阶函数# 把变量指向函数f=absf(-10)#函数名其实也只是指向函数的变量#abs=10#abs(-10)# 会发生错误# 既然变量可以指向函数，def add(x,y,f): return f(x)+f(y)a=add(-5,6,add)# map()和reduce()函数def f(x) return x*xmap(f,[1,2,3,4,5,6,7,8,9])# map作为高阶函数，把运算规则抽象def add(x,y): return x+yreduce(add, [1,3,5,7,9])# 配合map()，我们可以把str转换成intdef char2num(s): return&#123;'0':0, '1':1,'2':2,'3':3,'4':4,'5':5 '6':6,'7':7,'8':8,'9':9&#125;[s]reduce(fn,map(char2num,'13579'))def str2int(s): def fn(x,y): return x*10+y def char2num(s): return&#123;'0':0, '1':1,'2':2,'3':3,'4':4,'5':5 '6':6,'7':7,'8':8,'9':9&#125;[s] return reduce(fn,map(char2num,s))# filter()函数用于过滤序列# filter()也接收一个函数和一个序列，和map()不同的是，filter()# 把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素def is_odd(n): return n%2==1filter(is_odd,[1,2,3,4,5,6,9,10,15])# 排序算法,sorted()也是高阶函数sorted([36,5,12,9,21])# 实现倒序排序def reversed_cmp(x,y): if x&gt;y: return -1 if x&lt;y: return 1 return 0sorted([36,5,12,9,21],reversed_cmp)# 关于排序比较字符串，按照ASCII大小比较# 忽略大小写def cmp_ignore_case(s1,s2): u1 = s1.upper() u2 = s2.upper() if u1&lt;u2: return -1 if u1&gt;u2: return 1 return 0sorted('bob','about','Zoo','Gredit',cmp_ignore_case)# 返回函数# 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回def lazy_sum(*args): def sum(): ax =0 for n in args: ax=ax+n return ax return sumf=lazy_sum(1,3,5,7,9)f()# 闭包def count(): fs=[] for x in range(1,4): def f(): return i*i fs.append(f) return fsf1, f2, f3 =count()# 匿名函数map(lambda, x: x*x, [1,2,3,4,5,6,7,8,9])# 关键字lambda表示匿名函数，冒号前面的x表示函数参数# 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数# 装饰器def now(): print '2017-05-06'# 函数对象有一个__name__属性，可以拿到函数的名字now.__name__# 假设我们要增加count函数的功能，比如在函数调用前后自动打印日志# 但又不希望修改count函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器# 打印日志def log(func): def wrapper(*args,**kw): print 'call %s():' % func.__name__ return func(*args,**kw) return wrapper# 借助@语法，把decorator置于函数的定义处@logdef now: print '2017-05-06'#在面向对象OOP的设计模式中，decorator被称为装饰模式# OOP的装饰模式需要继承和组合来实现，# 偏函数# python的functools模块提供了很多有用的功能，其中一个就是偏函数int('12345',base = 8)# 定义默认函数,装换二进制def int2(x,base =2): return int(x,base)# functools.partial 就是帮助我们创建一个偏函数，不需要问自己定义int2(),import functoolsin2 = functools.partial(int, base=2)# 简单总结functools.partial的作用就是，把一个函数的某些参数固定住(也就是设置默认值)，返回一个新的函数，调用这个新的函数会更简单# 当函数的参数太多，需要简化的时候，使用functools.partial可以创建新的函数# 模块# 一个.py文件就是一个模块# 可以引入package避免模块名字冲突# 每个包下面都有一个__init__.py文件，这个文件是必须存在的，否则python就把这个目录当成普通目录# 使用模块 #!/usr/bin/env python 让文件在Unix系统中能直接运行-- coding: utf-8 --‘a test module’# 模块的文档注释author= ‘jerry’ import sysdef test(): args =sys.argv if len(args) == 1: print ‘Hello,world!’ elif len(args)==2: print ‘Hello, %s!’ % args[1] else: print ‘Too many arguments!’ if name == ‘main‘: test() 1234567891011121314151617181920try: import cStringIO as StringIOexcept importError: #导入失败会捕捉到ImportError import StringIO# python 是动态语言# __XXX___这样的变量是特殊变量，可以直接引用，但是有特殊用途，自己的变量一般不用这种变量# _xxx和__xxx这样的函数或者变量就是非公开的(private)def _private_1(name): return &apos;Hello, %s&apos; %namedef _private_2(name): return &apos;Hi, %s&apos; % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[作息时间表]]></title>
      <url>%2F2017%2F04%2F23%2F%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[#考研作息时间表[TOC] 7:00 起床7:30 吃早饭8:00-9:00 背英语单词9:00-11:00 复习数学11:00-11;40 看英文周刊11:40-13:00 午饭和午休,洗脸养好精神13:00-17:00 复习专业课17:00-17:30 晚饭17:30-19:00 刷牛客网pat19:00-21:00 刷数学题目21:00-24:00 刷真题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于PageRank的理解]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%85%B3%E4%BA%8EPageRank%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[##google大法：PageRank的了解在网络检索课程上了解了PageRank这个东西，也是google为什么能在第二次搜索引擎竞争活下来的原因。PageRank由google创始人Larry Page发明和命名的。 主要目的是去measure the importance of website page。越多的链接指向的页面，则越重要。(这就好比社会上，某个领域的专家总是比门外汉对本专业有更大的权威性）google如此解释： 12345PageRank works by counting the number and quality of links to a page to determine a rough estimate of how importantthe website is. The underlying assumption is that more important websites are likely to receive more links from other websites]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期目标]]></title>
      <url>%2F2017%2F04%2F21%2F%E8%BF%91%E6%9C%9F%E7%9B%AE%E6%A0%87%2F</url>
      <content type="text"><![CDATA[#近期要完成的东西： 牛客网pat刷够20题准备报考pat 复习考研数学和专业课和英语（真是每天必备的），现在以刷题静心为目标。 近期有os课程设计，网络检索实验，数值计算实验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo优化]]></title>
      <url>%2F2017%2F04%2F20%2Fhexo%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[这几天一直在折腾自己的blog通过Hexo框架，选择排名第一的nexT。 应金洲学长的要求添加了评论功能(由于多说要关闭了不得不选其他的网站有的丑，有的必须翻墙，有的还需要备案，真是心累） 后来通过网上的教程又添加了查询功能，标签，网站图标等等。总体来说后期越来越得心应手，主要是作者已经把很多功能都集成好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>%2F2017%2F04%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[今天终于用Hexo搭建好了博客，刚开始操作起来真是麻烦，不过后期熟练之后各种得心应手，感觉自己搭载博客还是挺牛的，哈哈。 Hexo的几种命令Create a new post（放在_post文件夹下）123$ hexo new "My New Post"//这个是新建page$hexo new page "tag" More info: Writing 跑本地服务器123$ hexo server//或者$hexo s --debug More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites12$ hexo deploy//不知道为什么，发布到github必须先用hexo g, 然后 hexo d More info: Deployment 搭建hexo+github所有命令12345$ npm install hexo -g #安装 $ npm update hexo -g #升级 $ npm install hexo --save $ hexo init$ npm install]]></content>
    </entry>

    
  
  
</search>
